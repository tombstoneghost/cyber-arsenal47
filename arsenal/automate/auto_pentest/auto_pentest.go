package automate

import (
	ftp_miner "arsenal/auxiliary/ftp_miner"
	smb_miner "arsenal/auxiliary/smb_miner"
	directory_scanner "arsenal/scanners/directory_scanner"
	ftp_login "arsenal/scanners/ftp_login"
	port_scanner "arsenal/scanners/port_scanner"
	smb_login "arsenal/scanners/smb_login"
	vhost_scanner "arsenal/scanners/vhost_scanner"
	exploitDbSearch "arsenal/search/exploit_db_search"
	"fmt"
	"net"
	"os"
	"strings"
	"time"
)

func redirectOutputToFile(fileName string) (*os.File, func(), error) {
	file, err := os.OpenFile(fileName, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
	if err != nil {
		return nil, nil, err
	}

	// Backup original stdout
	origStdout := os.Stdout

	// Redirect stdout to file
	os.Stdout = file

	// Return the file and a function to restore stdout
	return file, func() {
		file.Close()
		os.Stdout = origStdout
		fmt.Printf("[>] Scan Report at %s\n", fileName)
		fmt.Println("[*] Automated pentest complete.")
	}, nil
}

func isIPAddress(ip string) bool {
	parsedIP := net.ParseIP(ip)
	return parsedIP != nil
}

func formatURL(target string, port int) string {
	if !strings.HasPrefix(target, "http://") && !strings.HasPrefix(target, "https://") {
		if port == 80 {
			target = "http://" + target
		} else if port == 443 {
			target = "https://" + target
		}
	}

	if !strings.HasSuffix(target, "/") {
		target += "/"
	}

	return target
}

func AutoPentest_Init(target string, portStart int, portEnd int, nmap bool, hostDiscovery bool, protocol string,
	dirScanWordlist string, errorCodeCount int, errorCodes []int, extensionCount int, extensions []string, fileOnly bool,
	vhostScanWordlist string, ssl bool, ignoreBodyLength int, userFile string, passFile string, workerCount int) {
	fmt.Printf("[!] Starting automated pentest on: %s\n", target)

	timeStamp := time.Now().Format("20060102_150405")
	logFileName := fmt.Sprintf("auto_pentest_%s_%s.log", target, timeStamp)

	// Redirect output to log file
	logFile, restoreStdout, err := redirectOutputToFile(logFileName)
	if err != nil {
		fmt.Println("Failed to create log file:", err)
		return
	}
	defer restoreStdout()
	defer logFile.Close()

	targetArray := []string{target}

	// Run the port scanner first
	scan_report, nmap_results := port_scanner.Scanner_init(targetArray, portStart, portEnd, nmap, hostDiscovery, protocol)
	open_ports := scan_report[target]

	fmt.Println("Open Ports: ", open_ports)

	// Based on open ports, call the respective modules
	for _, port := range open_ports {
		switch port {
		case 21: // FTP
			fmt.Println("[*] FTP Port detected")
			login, user, pass := ftp_login.FTPBruteForcer_Init(target, userFile, passFile, workerCount)
			fmt.Printf("\n[!] Credentials for FTP: %s %s\n", user, pass)
			if login {
				ftp_miner.FTPMiner_Init(target, user, pass)
			}
		case 445: // SMB
			fmt.Println("[*] SMB Port detected")
			login, user, pass := smb_login.SMBBruteForce_Init(target, userFile, passFile, workerCount)
			fmt.Printf("\n[!] Credentials for SMB: %s %s\n", user, pass)
			if login {
				smb_miner.SMBMiner_Init(target, user, pass)
			}
		case 80, 443: // HTTP/HTTPS
			fmt.Println("[*] Web server detected")
			target_url := formatURL(target, port)
			directory_scanner.Scanner_init(target_url, dirScanWordlist, errorCodes, extensions, fileOnly, workerCount)
			if !isIPAddress(target) {
				vhost_scanner.Scanner_init(target, vhostScanWordlist, ssl, ignoreBodyLength, workerCount)
			} else {
				fmt.Println("[*] IP address detected, skipping vhost scanner.")
			}
		}
	}

	if len(nmap_results) > 0 {
		fmt.Println("[!] Searching for exploits for all the services found")
		for port, service := range nmap_results {
			fmt.Printf("[!] Searching for service [%s] running on port [%d]", service, port)
			exploitDbSearch.SearchExploitDB(service)
		}
	} else {
		fmt.Println("[-] Unable to get service details from Nmap Scans")
	}
}
